#!/usr/bin/env node

var child_process = require('child_process');
var fs = require('fs');

var branch;
var tags;
var remoteTags;
var tagsBuildless;
var currentNoBuildNumber;
var nextBuild;
var packageJson;
var targetBuild;
var forceTarget = false;
var prerelease;
var bump;

if(process.argv.length < 3) {
    _printHelp();
    return;
} else {
    var arg = process.argv[2];
    var re;
    if(re = arg.match(/^(\d+)\.(\d+)\.(\d+)$/)) {
        targetBuild = [parseInt(re[1]), parseInt(re[2]), parseInt(re[3])];
        forceTarget = process.argv[3] === "--force";
        _log("    # version: " + targetBuild);
        _log("    # forcing: " + forceTarget);
    } else if(re = arg.match(/^(major|minor|patch)$/)) {
        bump = re[1];
        _log("    # bumping " + bump + " version");
    } else if(arg.match(/^-+h(?:elp)?$/)) {
        _printHelp();
        return;
    } else {
        if(arg.match(/\+/)) {
            throw new Error("prelease name can't have a '+' in it");
        }
        prerelease = arg;
        _log("    # bumping build on prelease: " + prerelease);
    }
}
//return;

_functionStack = [
    _callGitFetch,
    _saveGitCurrentBranch,
    _getExistingGitTags,
    _getExistingRemoteGitTags,
    _getCurrentVersion,
    _calculateNextVersion,
    _requestPermission,
    _deleteRemoteGitTagIfForced,
    _savePackageJson,
//    _writeInglesideMeta,
//    _writeIndexMeta,
    _callGitCommit,
    _callGitPush,
    _tagVersion,
    _callGitPushTags,
    _announceVersion
];
_resumeFunctionStack();

function _resumeFunctionStack() {
    if (_functionStack.length) {
        _functionStack.shift()();
    }
}

function _printHelp() {
    console.log("HOW TO USE:");
    console.log("\n# bump build on prerelease");
    console.log("# (sorry you can't name prereleases: '1.2.3', 'major', 'minor', 'patch', or '-h')");
    console.log("   semverily alpha");
    console.log("   semverily rc2");
    console.log("   semverily my-special-name");
    console.log("\n# bump part of the version");
    console.log("   semverily major");
    console.log("   semverily minor");
    console.log("   semverily patch");
    console.log("\n# publish specific version");
    console.log("   semverily 1.2.3");
    console.log("\n# force publish specific version");
    console.log("   semverily 1.2.3 --force");
}

function _handleCBArgs(err, stdout, stderr, ignoreErrors) {
    if(stderr) {
//        process.stdout.write(stderr);
    }
    if(stdout) {
//        process.stdout.write(stdout);
    }
    if(!ignoreErrors && err) {
        throw err;
    }
}

function _log(comment, color) {
    //black, red, green, yellow, blue, magenta, cyan, white
    if(color === undefined) {
        color = 0;
    }
    color = color + 30;
    console.log("\033[" + color + "m" + comment + "\033[0m");
}

function _runCommand(command, callback, resume, ignoreErrors) {
    _log(command, 4);
    if(resume === undefined) {
        resume = true;
    }
    child_process.exec(command, function (err, stdout, stderr) {
        _handleCBArgs(err, stdout, stderr, ignoreErrors);
        _log("    # " + command + " # (complete)", 3);
        if(callback) {
            callback(stdout);
        }
        if(resume) {
            _resumeFunctionStack();
        }
    });
}

function _callGitFetch() {
    _runCommand("git fetch");
}

function _getExistingGitTags() {
    _runCommand("git tag", function (stdout) {
        tags = stdout.split(/\r\n|\r|\n/);
    });
}

function _getExistingRemoteGitTags() {
    _runCommand("git ls-remote --tags origin", function (stdout) {
        remoteTags = stdout.split(/\r\n|\r|\n/);
        tagsBuildless = [];
        for(var i = 0; i < tags.length; i++) {
            var re;
            if(re = tags[i].match(/[^-]*/)) {
                tagsBuildless.push(re[0]);
            }
        }
    });
}

function _saveGitCurrentBranch() {
    _runCommand("git rev-parse --abbrev-ref HEAD", function (stdout) {
        branch = stdout.split(/\r\n|\r|\n/)[0];
        _log("    # current branch: " + branch, 5);
    });
}

function _getCurrentVersion() {
    fs.readFile('package.json', function (err, data) {
        _handleCBArgs(err);
        packageJson = JSON.parse(data);
        var v = packageJson.version.match(/^(\d+)\.(\d+)\.(\d+)([-+].*)?/);
        var meta = v[4];
        v = [parseInt(v[1]), parseInt(v[2]), parseInt(v[3])];
        currentNoBuildNumber = v.join('.');

        _log("    # current version: " + currentNoBuildNumber, 5);
        if(meta) {
            var preMatch = meta.match(/-([^+]+)/);
            if(preMatch) {
                _log("    # current pre-release: " + preMatch[1], 5);
            }
            var buildMatch = meta.match(/\+(.+)/);
            if(buildMatch) {
                _log("    # current build: " + buildMatch[1], 5);
            }
        }
        _resumeFunctionStack();
    });
}

function _calculateNextVersion() {
    if(targetBuild) {
        _setTargetBuild();
    } else if(prerelease) {
        _setPreReleaseVersion();
    }
}
function _setTargetBuild() {
    var testTarget = targetBuild.join('.');
    if(forceTarget || remoteTags.indexOf(testTarget) === -1) {
        nextBuild = testTarget;
        _resumeFunctionStack();
    } else {
        throw new Error("release already tagged with " + testTarget + " use --force to override");
    }

}
function _setPreReleaseVersion() {
    var testVersion;
    var today = new Date();
    var incrementee = 0;
    do {
        testVersion = currentNoBuildNumber + "-" + prerelease + "+" + branch + "-" + today.getFullYear() + "." + (today.getMonth() + 1) + "." + today.getDate();
        if (incrementee) {
            testVersion += "-" + incrementee;
        }
        incrementee++;
    } while (tags.indexOf(testVersion) >= 0 || remoteTags.indexOf(testVersion) >= 0);
    nextBuild = testVersion;
    _log("    # next pre-release version: " +  nextBuild, 5);
    _resumeFunctionStack();
}

function _requestPermission() {
    process.stdout.write("    # is this okay (yes)?");
    process.stdin.on('data', function(data) {
        data = data.split(/\r\n|\r|\n/)[0];
        process.stdin.pause();
        if(data.match(/^(?:yes|y|)$/)) {
            _resumeFunctionStack();
        } else {
            _log("    # cancelled (no action taken)", 1);
        }
    });
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
}

function _deleteRemoteGitTagIfForced() {
    if(forceTarget && tags.indexOf(nextBuild) !== -1) {
        _runCommand("git tag -d " + nextBuild, function () {
            if(remoteTags.indexOf(nextBuild) !== -1) {
                _runCommand("git push --delete origin " + nextBuild);
            } else {
                _resumeFunctionStack();
            }
        }, false);
    } else {
        _resumeFunctionStack();
    }
}

function _tagVersion() {
    _runCommand("git tag -a " + nextBuild + " -m \"auto incremented\"");
}

function _savePackageJson() {
    packageJson.version = nextBuild;
    fs.writeFile('package.json', JSON.stringify(packageJson, null, '  '), function (err) {
        _handleCBArgs(err);
        _log("    # successfully updated package.json", 6);
        _resumeFunctionStack();
    });
}

function _writeInglesideMeta() {
    packageJson.version = nextBuild;
    fs.readFile('ingleside.html', function (err, data) {
        _handleCBArgs(err);
        _log("    # updating ingleside.html", 6);
        data = data.toString().replace(/<meta name="build" [^>]*>/, '<meta name="build" content="' + nextBuild + '">');
        fs.writeFile('ingleside.html', data, function (err) {
            if (err) {
                throw err;
            }
            _log("    # successfully updated ingleside.html", 6);
            _resumeFunctionStack();
        });
    });
}

function _writeIndexMeta() {
    packageJson.version = nextBuild;
    fs.readFile('index.html', function (err, data) {
        _handleCBArgs(err);
        _log("    # updating index.html", 6);
        data = data.toString().replace(/<meta name="build" [^>]*>/, '<meta name="build" content="' + nextBuild + '">');
        fs.writeFile('index.html', data, function (err) {
            if (err) {
                throw err;
            }
            _log("    # successfully updated ingleside.html", 6);
            _resumeFunctionStack();
        });
    });
}

function _callGitCommit() {
    var command = "git commit -am \"automatically changing version to " + nextBuild + "\" --no-verify";
    _runCommand(command, null, true, true); //ignore errors (--force may cause a "nothing to commit" error)
}

//function _callGitPull() {
//    child_process.exec("git pull", function (err, stdout, stderr) {
//        _handleCBArgs(err, stdout, stderr);
//        console.log("pulled");
//        _resumeFunctionStack();
//    });
//}

function _callGitPush() {
    _runCommand("git push origin head");
}

function _callGitPushTags() {
    _runCommand("git push origin head --tags");
}

function _announceVersion() {
    _log("# Version bumped to:  ---==={ " + nextBuild + " }===---", 5);
    _resumeFunctionStack();
}